pub(crate) enum Opcode {
    Halt,
    ClearScreen,
    Return,
    JumpToAddress(u16),
    CallAddress(u16),
    SkipIfRegEqualsByte(u8, u8),
    SkipIfRegNotEqualsByte(u8, u8),
    SkipIfRegEqualsReg(u8, u8),
    LoadByteIntoReg(u8, u8),
    AddByteToReg(u8, u8),
    LoadRegIntoReg(u8, u8),
    OrRegWithReg(u8, u8),
    AndRegWithReg(u8, u8),
    XorRegWithReg(u8, u8),
    AddRegToReg(u8, u8),
    SubtractRegFromReg(u8, u8),
    ShiftRight(u8),
    SubstractRegFromOtherReg(u8, u8),
    ShiftLeft(u8),
    SkipIfRegNotEqualsReg(u8, u8),
    LoadIndex(u16),
    JumpToAddressPlusV0(u16),
    RandomByte(u8, u8),
    DrawSprite(u8, u8, u8),
    SkipIfKeyPressed(u8),
    LoadDelayTimerIntoReg(u8),
    LoadKeyIntoReg(u8),
    LoadRegIntoDelayTimer(u8),
    LoadRegIntoSoundTimer(u8),
    AddRegToIndex(u8),
    LoadIndexFromReg(u16),
    LoadFontIntoReg(u8),
    LoadBCDIntoMem(u8),
    StoreRegsIntoMem(u8),
    LoadRegsFromMem(u8),
    Unknown,
}

pub(crate) fn parse_opcode(opcode: u16) -> Opcode {
    let reg_x = ((opcode & 0x0F00) >> 8) as u8;
    let reg_y = ((opcode & 0x00F0) >> 4) as u8;
    let k = (opcode & 0x00FF) as u8;
    let n = (opcode & 0x000F) as u8;
    let addr = opcode & 0x0FFF;
    match opcode & 0xF000 {
        0x0000 => match opcode & 0x00FF {
            0x0000 => Opcode::Halt,
            0x00E0 => Opcode::ClearScreen,
            0x00EE => Opcode::Return,
            _ => Opcode::Unknown,
        },
        0x1000 => Opcode::JumpToAddress(addr),
        0x2000 => Opcode::CallAddress(addr),
        0x3000 => Opcode::SkipIfRegEqualsByte(reg_x, k),
        0x4000 => Opcode::SkipIfRegNotEqualsByte(reg_x, k),
        0x5000 => Opcode::SkipIfRegEqualsReg(reg_x, reg_y),
        0x6000 => Opcode::LoadByteIntoReg(reg_x, k),
        0x7000 => Opcode::AddByteToReg(reg_x, k),
        0x8000 => match opcode & 0x000F {
            0x0000 => Opcode::LoadRegIntoReg(reg_x, reg_y),
            0x0001 => Opcode::OrRegWithReg(reg_x, reg_y),
            0x0002 => Opcode::AndRegWithReg(reg_x, reg_y),
            0x0003 => Opcode::XorRegWithReg(reg_x, reg_y),
            0x0004 => Opcode::AddRegToReg(reg_x, reg_y),
            0x0005 => Opcode::SubtractRegFromReg(reg_x, reg_y),
            0x0006 => Opcode::ShiftRight(reg_x),
            0x0007 => Opcode::SubstractRegFromOtherReg(reg_x, reg_y),
            0x000E => Opcode::ShiftLeft(reg_x),
            _ => Opcode::Unknown,
        },
        0x9000 => Opcode::SkipIfRegNotEqualsReg(reg_x, reg_y),
        0xA000 => Opcode::LoadIndex(addr),
        0xB000 => Opcode::JumpToAddressPlusV0(addr),
        0xC000 => Opcode::RandomByte(reg_x, k),
        0xD000 => Opcode::DrawSprite(reg_x, reg_y, n),
        0xE000 => Opcode::SkipIfKeyPressed(reg_x),
        0xF000 => match opcode & 0x00FF {
            0x0007 => Opcode::LoadDelayTimerIntoReg(reg_x),
            0x000A => Opcode::LoadKeyIntoReg(reg_x),
            0x0015 => Opcode::LoadRegIntoDelayTimer(reg_x),
            0x0018 => Opcode::LoadRegIntoSoundTimer(reg_x),
            0x001E => Opcode::AddRegToIndex(reg_x),
            0x0029 => Opcode::LoadFontIntoReg(reg_x),
            0x0033 => Opcode::LoadBCDIntoMem(reg_x),
            0x0055 => Opcode::StoreRegsIntoMem(reg_x),
            0x0065 => Opcode::LoadRegsFromMem(reg_x),
            _ => Opcode::Unknown,
        }
        _ => Opcode::Unknown,
    }
}
